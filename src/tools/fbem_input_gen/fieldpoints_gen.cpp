/*
 * This program reads the displacement file for the simulated rigid objects,
 * and generates the field points file for FastBem solver
 */
#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <stdlib.h>
#include <vector>
#include <unistd.h>

#include <config.h>
#include <linearalgebra/Quaternion.hpp>
#include <geometry/Point3.hpp>
#include <logging/logging.h>

using namespace std;

static void usage(const char* cmd)
{
    printf("Usage: %s -i <input file> -o <output file ptn> -t <ts> x y z\n", cmd);
    printf("        -i <input file>         The input displacement file, generated by io/RigidObjDispRecorder\n");
    printf("        -x <x0 file>            The input file to store the position of initial mass center for\n");
    printf("                                each object: the format of the input file is like\n");
    printf("                                <id>   <x0.x>  <x0.y>  <x0.z>\n");
    printf("        -o <output file ptn>    Output file name pattern. By default it is output-%%d.txt\n");
    printf("        -n <max # of objs>      Maximum no. of rigid objs in the input file\n");
    printf("        -t <ts>                 Minimum time gap between the continuous field point samples\n");
    printf("                                This value is used to downsample the field points with a smaller\n");
    printf("                                time step than that used in simulation\n");
    printf("        x y z                   The position of listener\n");
}

static string dispFile;
static string x0File;
static string outputPtn = "output-%d.txt";
static Point3d  listenPos;
static int    nObj = 0;
static double tsGap = 0;

static vector< vector<double> >     tsSamples;
static vector< vector<Point3d> >    fieldPts;
static vector< Point3d >            initPos;

static void parse_cmd(int argc, char* argv[])
{
    int opt;
    while ( optind + 3 < argc && (opt = getopt(argc, argv, "hx:i:o:n:t:")) != -1 )
    {
        switch (opt)
        {
            case 'h':
                usage(argv[0]);
                exit(0);
            case 'x':
                x0File = optarg;
                break;
            case 'n':
                nObj = atoi(optarg);
                break;
            case 'i':
                dispFile = optarg;
                break;
            case 'o':
                outputPtn = optarg;
                break;
            case 't':
                tsGap = atof(optarg);
                break;
        }
    }

    if ( optind + 3 != argc )
    {
        LOGGING_ERROR("Listener's position needs to be specified");
        exit(1);
    }
    listenPos.set(atof(argv[optind]), 
                  atof(argv[optind+1]),
                  atof(argv[optind+2]));
    LOGGING_INFO("INPUT=%s OUTPUT=%s POS=(%f,%f,%f)",
            dispFile.c_str(), outputPtn.c_str(),
            listenPos.x, listenPos.y, listenPos.z);
}

/*
 * load the initial mass center positions
 */
static void load_initial_mass_centers(const char* file)
{
    initPos.resize(nObj);

    ifstream fin(file);
    if ( fin.fail() )
    {
        LOGGING_ERROR("Cannot open file: %s", file);
        exit(2);
    }

    int id; 
    double x, y, z;
    while ( fin >> id >> x >> y >> z )
    {
        if ( id >= nObj ) 
        {
            LOGGING_ERROR("ID[%d] in initial position file is out of range", id);
            exit(2);
        }
        initPos[id].set(x, y, z);
    }
    fin.close();
}

/*
 * load the displacement at each time step
 */
static void load_displacement(const char* file)
{
    tsSamples.resize(nObj);
    fieldPts.resize(nObj);

    ifstream fin(file, ios::binary);
    if ( fin.fail() )
    {
        LOGGING_ERROR("Cannot open file: %s", file);
        exit(2);
    }

    double ts;
    int id;
    Point3<REAL>     translate;
    Vector3<REAL>    tvec;
    Quaternion<REAL> rotate, invrot;

    fin.read((char *)&ts, sizeof(double));
    while ( !fin.fail() )
    {
        fin.read((char *)&id, sizeof(int));
        while ( !fin.fail() && id >= 0 )
        {
            fin.read((char *)&translate, sizeof(Point3<REAL>));
            fin.read((char *)&rotate, sizeof(Quaternion<REAL>));

            if ( tsSamples[id].empty() || ts - tsSamples[id].back() >= tsGap )
            {
                tsSamples[id].push_back(ts);

                //// compute the corresponding field points at this time step
                invrot = rotate.conjugate();
                tvec = listenPos - translate;
                invrot.rotate_vector(tvec);
                tvec += initPos[id];
                fieldPts[id].push_back(tvec);
            }

            fin.read((char *)&id, sizeof(int));
        }

        fin.read((char *)&ts, sizeof(double));
    }

    fin.close();
}

static void gen_files()
{
    char file[128];
    ofstream fout;

    fout << setprecision(12);
    for(int i = 0;i < nObj;++ i)
    {
        if ( tsSamples[i].empty() )
        {
            LOGGING_WARNING("Ignore rigid obj ID=%d", i);
            continue;
        }

        sprintf(file, outputPtn.c_str(), i);
        fout.open(file);
        if ( fout.fail() )
        {
            LOGGING_ERROR("Cannot open file[%s] to write", file);
            exit(1);
        }
        LOGGING_INFO("write to file: %s", file);
        //fout << tsSamples[i].size() << endl;
        for(int j = 0;j < (int)tsSamples[i].size();++ j)
            fout << tsSamples[i][j] << ' '
                 << fieldPts[i][j].x << ' '
                 << fieldPts[i][j].y << ' '
                 << fieldPts[i][j].z << endl;
        fout.close();
    }
}

int main(int argc, char* argv[])
{
    LoggingManager::instance().set_logging_level(LOG_INFO);

    parse_cmd(argc, argv);
    if ( nObj <= 0 )
    {
        LOGGING_ERROR("The max # of rigid obj is unknown");
        exit(1);
    }

    if ( dispFile.empty() )
    {
        LOGGING_ERROR("Specify the input displacement file");
        exit(1);
    }

    if ( x0File.empty() ) 
    {
        LOGGING_ERROR("Specify the file for initial mass center positions");
        exit(1);
    }

    load_initial_mass_centers(x0File.c_str());
    load_displacement(dispFile.c_str());
    gen_files();
    return 0;
}
